#+startup: nonum
#+options: ':nil *:t -:t ::t <:t H:5 \n:nil ^:{} anchor:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t
#+options: inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:nil title:t toc:5 todo:t |:t
#+title: Semantic Objects Modeling Language
#+date: <2023-11-30>
#+author: Vladimir Alexiev
#+email: vladimir.alexiev@ontotext.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 26.1 (Org mode 9.2.2)

* Table of Contents                                 :TOC:noexport:
:PROPERTIES:
:TOC:      :include all
:CUSTOM_ID: table-of-contents
:END:

:CONTENTS:
- [[#intro][Intro]]
  - [[#why-soml][Why SOML?]]
  - [[#similar-schema-languages][Similar Schema Languages]]
  - [[#what-is-soml][What is SOML]]
- [[#complex-schema-company-graph][Complex Schema (Company Graph)]]
  - [[#example-class][Example Class:]]
  - [[#example-inverse-alias][Example Inverse Alias]]
  - [[#example-diagram-exchange-listing-soml][Example Diagram: Exchange Listing SOML]]
  - [[#example-diagram-exchange-listing-rdf][Example Diagram: Exchange Listing RDF]]
- [[#soml-tooling][SOML Tooling]]
  - [[#owl2soml][owl2soml]]
  - [[#tsv2soml][tsv2soml]]
    - [[#reusing-property-characteristics][Reusing Property Characteristics]]
  - [[#soml-map][soml-map]]
  - [[#tsv2owl][tsv2owl]]
    - [[#rdf-replacement][RDF replacement]]
  - [[#soml2puml][soml2puml]]
- [[#tricky-points-and-deficiencies][Tricky Points and Deficiencies]]
  - [[#graphql-type-vs-rdftype][GraphQL Type vs rdf:type]]
  - [[#single-vs-multiple-value-props][Single vs Multiple-Value Props]]
  - [[#inverse-aliases][Inverse Aliases]]
  - [[#literals][Literals]]
  - [[#extended-pattern-prefix--regex][Extended Pattern (Prefix + Regex)]]
  - [[#iri-generation][IRI Generation]]
  - [[#schema-inclusionmodularity][Schema Inclusion/Modularity]]
:END:

* Intro
:PROPERTIES:
:CUSTOM_ID: intro
:END:

The Semantic Objects Modeling Language (SOML)
is a simple YAML-based language for describing business objects (business entities, domain objects) 
that are handled using semantic technologies and GraphQL.
SOML is the language of the Ontotext Platform.

The Ontotext Platform helps create knowledge graphs in an easier way,
both using and enabling text analytics to interlink and enrich knowledge graphs,
and enabling better search, exploration, classification, and recommendation across diverse information spaces.

Version 3.0 of the Platform was released at the end of 2019 and is under active develoment and evolution.
- It is documented at http://platform.ontotext.com/, including:
  - [[http://platform.ontotext.com/semantic-objects/semantic-objects.html][Semantic Objects as a Service (SOaaS)]]
  - [[http://platform.ontotext.com/soml/index.html][Semantic Objects Modeling Language (SOML)]]
  - [[http://platform.ontotext.com/tutorials/soaas-tutorial.html][SOaaS Tutorial]]
- The blog post [[https://www.ontotext.com/blog/the-rise-of-the-knowledge-graph/][A New Hope: The Rise of the Knowledge Graph]] 
  (Navigating through the Star Wars universe with knowledge graphs, SPARQL and GraphQL),
  6 December 2019
  introduces the platform, 
  compares RDF and GraphQL representations of a domain (Star Wars),
  and shows interactive GraphQL queries.

This blog goes in-depth on SOML: 
motivates the use of SOML, 
describes some tricky points of SOML usage and GraphQL deficiencies,
and introduces some SOML tooling for 
generating SOML (~tsv2soml~) and mapping RDF data (~soml-map~)

** Why SOML?
:PROPERTIES:
:CUSTOM_ID: why-soml
:END:

We often are asked why we had to introduce yet another object modeling language?
Why didn't we use existing semantic web mechanisms such as 
ontologies (RDFS or OWL) or shapes (SHACL or SHEX),
or schema mechanisms such as GraphQL schema, JSON schema and the like?
The answer is multi-fold:
- Semantic models are more than ontologies ::
  Every sizable semantic project (and many LOD datasets) use a number of ontologies together.
  While ontologies describe the vocabulary of classes and properties to use,
  extra mechanisms are required to describe how these elements are put together,
  and what are the data expectations about different kinds of nodes in the graph.
  One could do some of that with ontologies, 
  e.g. use OWL property cardinalities, 
  complex OWL classes to define polymorphic domains and ranges,
  and XSD datatype constructions to describe literal patterns.
  However, the inferential rather than validation semantics of RDFS and OWL 
  and their inherent complexity 
  have led people to use application profiles and RDF shapes instead.
- Lack of standardization ::
  While there are several implementations of GraphQL querying over RDF,
  each of them does it in a different way and there is no standardization.
  The [[https://www.topquadrant.com/graphql/graphql-shacl.html][TopQuadrant GraphQL to SHACL]] mapping comes close to using 
  SHACL for generating GraphQL schemas, but still uses custom extensions.
  Definitive mappings between SHACL and SHEX are not available.
  The [[https://www.w3.org/community/graphql-rdf/][Bridging GraphQL and RDF]] W3C Community Group has been launched (Jan 2020)
  with the mission to close this gap,
  and hopefully define standard mappings/crosswalks between SHACL, SHEX and 
  GraphQL schemas and validation mechanisms.
  We plan to participate actively in this group.
- Freedom to innovate :: 
  Our ambition is for the Ontotext platform to cover a wide variety of enterprise features.
  To be able to develop them at our own pace, we need a language where we can add such innovations.
  Examples include
  data validation based on RDF shapes (generated from SOML);
  Role-Based Access Control (RBAC);
  faceting, autocompletion and full-text search;
  aggregation;
  distribution of data to various stores through GraphDB Connectors and/or GraphQL Federation.
- Technology independence ::
  Flowing from the previous reason, we'd like SOML to be technology-independent to some degree.
  While we don't aim for a theoretical develpment that lives in a technological vacuum,
  we need to be able to generate a number of technical artefacts from the same business-level model.

** Similar Schema Languages
:PROPERTIES:
:CUSTOM_ID: similar-schema-languages
:END:

A number of schema languages have appeared recently that are based on YAML,
express business-level object models that are somewhat independent of technological choices,
and can render the models to a variety of schema technologies:

- [[https://biolink.github.io/biolinkml/][BioLink modeling language]].
  Models are authored in YAML. A variety of artefacts can be generated, including SHEX, JSON-Schema, OWL, Python dataclasses, ElasticSearch type definitions, 
  UML diagrams, Markdown pages for deployment in a GitHub pages site, etc.
- [[https://www.hl7.org/fhir/][HL7 FHIR]], which is a business-level language for expressing Health Care models 
  and has renditions in UML, XML, JSON, Turtle, SHEX.
- *a.ml*: [[https://a.ml/][Anything Modeling Language]] (see [[https://a.ml/docbook/][documentation]], [[https://a.ml/aml-spec/vocabularies/][vocabularies]], [[https://a.ml/aml-spec/dialects/][dialects]]),
  which targets mapping of YAML schemas to ontologies and SHACL shapes, 
  and YAML documents to RDF graphs.
- [[https://cloudinformationmodel.org/about.html][Cloud Information Model (CIM)]], which targets
  AML Vocabulary (conceptual model),
  AML Dialect (data shapes),
  RDFS (entities and relationships),
  SHACL (data shapes and constraints),
  SQL DDL (relational database schema),
  R2RML (mapping from relational schema to RDF),
  RAML (REST API data types),
  JSON Schema (data shapes)
- The Uber Graph Schema Language, a YAML language that is
  used to generate various artefacts (ProtoBuf, Avro, RDFS ontology, etc) 
  and to integrate *200 thousand* datasets at Uber.
  While not publically available, it's described in presentations by [[https://www.slideshare.net/joshsh][Joshua Shinavier]] including:
  - [[https://www.slideshare.net/joshsh/a-graph-is-a-graph-is-a-graph-equivalence-transformation-and-composition-of-graph-data-models-129403012/1][A Graph is a Graph is a Graph: Equivalence, Transformation, and Composition of Graph Data Models]] (Jan 2019).
  - [[https://www.slideshare.net/joshsh/building-an-enterprise-knowledge-graph-uber-lessons-from-reality][Building an Enterprise Knowledge Graph @Uber: Lessons from Reality]] (May 2019)

** What is SOML
:PROPERTIES:
:CUSTOM_ID: what-is-soml
:END:

At present SOML is very simple, but will evolve to include more features.
The overall structure of a SOML file (schema) is shown below.

#+begin_src yaml
    # comment
    id:          /soml/<identifier>
    label:       some name
    created:     yyyy-mm-dd
    updated:     yyyy-mm-dd
    creator:     name and/or URL
    versionInfo: version

    # comment
    specialPrefixes:
      base_iri:     <base>
      vocab_iri:    <vocab>
      vocab_prefix: <voc>
      ontology_iri: <ontology>
      shape_iri:    <shape>
    prefixes:
      <pfx>:        <namespace>

    # datatypes
    types:
      <type>:       {rdf: <xsd-type>,    graphql: <GQL-type>, descr: "...", graphqlExtension: <boolean>}
      <union-type>: {union: [<type>...], graphql: <GQL-type>, descr: "..."}

    # common property definitions
    properties:
      <prop>:  {label: "...", descr: "...", range: <datatype|Obj>, rangeCheck: <boolean>, typeCast: <boolean>,
                kind: (object|literal|mixed), min: <default 0>, max: <default 1>,
                inverseAlias: <prop>, inverse: <prop>, rdfProp: pfx:prop, symmetric: <boolean>, regex: '<regex>', prefix: "<string>"}

    # object class definitions
    objects:
      <Obj>:  {label: "...", descr: "...", regex: '<regex>', prefix: "<string>",
               typeProp: <prop>, type: [<iri>...], name: <prop>, inherits: <Obj>, kind: (abstract|supertype)}
        props:
          <prop>: ...

#+end_src

From this schema the Platform generates a complex GraphQL schema 
including a fairly complete querying language that allows you to
find any kind of object, filter, order, navigate through the KG, 
and do pagination (limit, offset).

You can find details in the [[http://platform.ontotext.com/soml/index.html][SOML documentation]], while below we describe 
some tricky points of SOML usage and GraphQL deficiencies, and some tooling.

* Complex Schema (Company Graph)
:PROPERTIES:
:CUSTOM_ID: complex-schema-company-graph
:END:

To introduce the proper context for this blog (working with complex SOML schemas),
we'll describe the Ontotext Company Graph (ONTO CG) ontology and model.
It's a medium-high complexity data model that reuses 14 ontologies and adds classes and props of its own.
Of its 24 classes and 150 props, about half are reused and half are created especially for CG.
It's fairly typical data model for the kind of projects that Ontotext deals with.

Creating the ONTO CG knowledge graph is part of
the [[https://www.ontotext.com/cima/][Intelligent Matching and Linking of Company Data (CIMA)]] research project.
We are integrating data from open and a few proprietary datasets. The emphasis of the project is on financial transactions, industrial classification, company size/importance observations (e.g. annual sales, number of employees), etc.

The following table shows the count of classes and properties defined by the ONTO-CG ontology, as well as those reused from other ontologies.

#+CAPTION: Ontology reuse and extension in Ontotext Company Graph.
| Prefix | Ontology                             | Classes | Props |
|--------+--------------------------------------+---------+-------|
| cg     | Ontotext Company Graph               |      12 |    70 |
| adms   | Asset Description Metadata Schema    |       1 |     1 |
| dcat   | Data Catalog Vocabulary              |         |     3 |
| dct    | Dublin Core Terms                    |         |     8 |
| ebg    | euBusinessGraph                      |       1 |    12 |
| gn     | GeoNames                             |       1 |     9 |
| locn   | W3C Location Ontology                |       1 |     8 |
| org    | W3C Core Organization Ontology       |       1 |     5 |
| qb     | W3C Cube Ontology                    |       1 |     1 |
| rov    | W3C Registered Organization          |       1 |     4 |
| schema | Schema.org                           |       3 |    12 |
| skos   | Simple Knowledge Organization System |       1 |     6 |
| time   | W3C Time Ontology                    |         |     2 |
| void   | Vocabulary of Interlinked Datasets   |       1 |     7 |
| wgs84  | World Geodetic Survey                |         |     2 |
|--------+--------------------------------------+---------+-------|
|        |                                      |      24 |   150 |

ONTO CG builds upon the results of the euBusinessGraph project.
The euBusinessGraph semantic model and dataset covers the following
(we have submitted a description of it to a prominent journal on semantic technologies):
- Basic firmography (legal names, preferred name) 
- Basic person info
- Geography, address, hieararchical administrative divisions
- Company legal type and status
- Industry classification (based on NACE)
- Identifiers from Official registers and others
- Company officers and directors (positions, using ~org:Membership~)
- Datasets, providers, dataset descriptions

ONTO-CG steps on the euBusinessGraph model and adds the following:

- ~IdentifierSystems~: We extend the euBusinessGraph idea of generalized identifiers to record any kind of potentially useful identification info in a generic way: phone, email, website, blog, logo/image; profile links and identifiers in various external systems such as: Wikidata, DBpedia, Facebook, LinkedIn, Twitter, Youtube, Reddit, Github, CrunchBase, OpenCorporates, Thomson Reuters permid (TR), ISO 10383 Market Identifier Code (MIC); research-oriented identifiers such as CrossRef funder, Microsoft Academic Graph, Global Research Identifier Database (GRID), Research Organization Registry (ROR), Virtual International Authority File (VIAF).
- ~cg:StockExchange~: a Stock exchange where companies can offer shares or other securities. We record MIC and TR exchange codes as identifiers.
- ~cg:Event~ and ~cg:EventAppearance~: Conference, workshop, meetup, etc where the work of a certain person or company may be highlighted.
- ~gn:Feature~: While the euBusinessGraph geographic hierarchy is based on EuroStat NUTS and LAU, ONTO-CG uses Geonames locations to implement geographic matching, auto-completion and faceting. We are particularly interested in the 3 levels Country, Region, City that we have defined as particular lists of gn:featureCodes (e.g. Country corresponds to ~gn:A.PCLI, gn:A.PCLD, gn:A.PCLIX, gn:A.PCLS, gn:A.PCL, gn:A.TERR, gn:A.PCLF~).
- ~cg:AcademicQualification~: Academic degree (completed or not) of a person at a scholl in an academic major.
- ~qb:Observation~: Statistical or other observation about an object (typically company), such as annual sales, number of employees, etc. May be for a particular year, point in time, or without date (current).
- ~cg:Transaction~: Financial transaction that gives money to a company in return for shares or other consideration.
- ~cg:OrganizationRelation~: Relation between two agents. For asymmetric relations we use two fields "agentMinor" (e.g. subsidiary, owned, supplier) and "agentMajor" (e.g. parent, owner, customer); for symmetric relations we use the field "agent" twice. Usually these are Organizations, but "owner" could involve Persons.
- Sourcing (provenance) for each node:
    - ~void:Dataset~: Dataset as source of entities
    - ~void:Linkset~: Linkset as source of identifiers (links)
    - ~cg:SourceMatch~: Cluster of matched lower-level entities as the source of a higher-level entity.

In addition to the above new classes, ONTO-CG adds:
- A 2-level data model where data from individual datasets sits at a lower (KG-building) level, and after matching and data fusion is promoted at a higher (data consumption) level.
- Various extra fields, e.g. ~cg:geoPrecision~ "Precision of geo coordinates in meters (e.g. street address or building -> 30.8)" to complement ~ebg:geoResolution~ "Resolution of geo coordinates as a categorial value (e.g. building -> ~<resolution/L9>~)"
- Various flags, e.g. for Organization (~cg:isResearch~), Position (~cg:isCurrent, cg:isPrimary~), AcademicQualification (~cg:isCompleted~), ExchangeListing, OrganizationRelation (~cg:isCurrent~)
- Business nomenclatures (~skos:ConceptScheme~): ~Organization Type, Legal Form, Organization Status, Industry, Investor Type, Geo Coordinate Resolution, Address Type, Observation Type, Gender, Event Type, Event Appearance Type, Position Type, Transaction Type, Relation Type~

The full CG schema is included: [[./schemas/CG.yaml][CG.yaml]]. Below we show a couple of typical examples.

** Example Class: 
:PROPERTIES:
:CUSTOM_ID: example-class
:END:

#+begin_src yaml
  ExchangeListing:
    label: "Exchange Listing"
    inherits: Transaction
    type: [cg:ExchangeListing]
    descr: "Public offering (IPO, SPO etc) wheres the company receives money from the wide public, and as a result is listed for trading on an exchange"
    props:
      exchange:
        label: "exchange"
        range: StockExchange
        min: 1
        rdfProp: cg:exchange
        descr: "Stock exchange"
      stockSymbol:
        label: "stock symbol"
        range: string
        rdfProp: cg:stockSymbol
        descr: "Stock symbol (ticker). TODO: this should also be represented as an Identifier?"
      valuation:
        label: "valuation (MUSD)"
        range: decimal
        rdfProp: cg:valuation
        descr: "Company valuation at IPO in MUSD"
      valuationLocal:
        label: "valuation (M local currency)"
        range: decimal
        rdfProp: cg:valuationLocal
        descr: "Company valuation at IPO in millions of local currency"
      valuationCurrency:
        label: "valuation currency"
        range: string
        rdfProp: cg:valuationCurrency
        descr: "Currency code of the valuation"
      dateEnd:
        descr: "Date delisted or left this exchange"
      isCurrent:
        rdfProp: cg:isCurrent
        descr: "Whether the listing is still effective"
#+end_src

If you look closely, you may wonder where the range and RDF mapping of ~dateEnd~ is defined.
It's in the list of reusable properties:

#+begin_src yaml
properties: # reused props
  dateEnd: {label: "dateCompleted", range: dateOrYearOrMonth, rdfProp: cg:dateEnd}
#+end_src

A more appropriate ~descr~ is given at the object level, overriding the generic description.

** Example Inverse Alias
:PROPERTIES:
:CUSTOM_ID: example-inverse-alias
:END:

A Position is an associative node between Person and Organization that adds more data (not shown):
#+begin_src yaml
  Position:
    label: "Position"
    inherits: BusinessObject
    type: [org:Membership]
    descr: "Position of a person in an organization, former or current"
    props:
      person: {label: "person", range: PersonCommon, min: 1, rdfProp: org:member}
      organization: {label: "organization", range: OrganizationCommon, min: 1, rdfProp: org:organization}
#+end_src

To allow navigation in any direction (not just from Position out, but also in), we add inverse aliases:

#+begin_src yaml
  PersonCommon:
    props:
      position: {label: "position", range: Position, inverseAlias: person}
  OrganizationCommon:
    props:
      position: {label: "position", range: Position, inverseAlias: organization}
#+end_src

** Example Diagram: Exchange Listing SOML
:PROPERTIES:
:CUSTOM_ID: example-diagram-exchange-listing-soml
:END:

For example, the figure below shows the stock exchange listing (IPO) of Apple on the Tokyo exchange and NASDAQ, and the listing of Nasdaq Inc (the company) on NASDAQ (the stock exchange).
- The data is integrated from Wikidata.
- This figure is generated from RDF Turtle using [[https://github.com/VladimirAlexiev/rdf2rml][rdfpuml]] (see V.Alexiev, [[http://rawgit2.com/VladimirAlexiev/my/master/pres/20161128-rdfpuml-rdf2rml/index.html][RDF by Example: rdfpuml for True RDF Diagrams, rdf2rml for R2RML Generation]], Semantic Web in Libraries (SWIB), Nov 2016.
- This version of the diagram uses original SOML (GraphQL) property and class names, i.e. all of them share the same namespace (expressed using the empty) prefix.
- It can be considered as a "logical" data model of how data should be queried with GraphQL

[[./eg/model-exchange-listing.ttl]]

[[./eg/model-exchange-listing.png]]

** Example Diagram: Exchange Listing RDF
:PROPERTIES:
:CUSTOM_ID: example-diagram-exchange-listing-rdf
:END:

This version of the diagram uses [[*soml-map][soml-map]] to map SOML names to RDF names in specific namespaces.
- So this can be considered the "physical" data model of data as it's stored in the semantic database

[[./eg/model-exchange-listing-mapped.ttl]]

[[./eg/model-exchange-listing-mapped.png]]

* SOML Tooling
:PROPERTIES:
:CUSTOM_ID: soml-tooling
:END:

** owl2soml
:PROPERTIES:
:CUSTOM_ID: owl2soml
:END:

This tool (written in Perl) generates SOML schemas from ontologies (that use RDFS, OWL and/or schema.org constructs).
It handles numerous features and has been integrated in the Ontotext Platform (reimplemented in Java).
See its own README.

** tsv2soml
:PROPERTIES:
:CUSTOM_ID: tsv2soml
:END:

Editing large schemas is often easier to do in a table, even when the schema language is simple.
(Also, this enables domain experts to participate in schema authoring, even if only editing the descriptions.)

The CG model was not written by hand, it was generated from a TSV (google sheet).

The sheet has 300 rows, and the generated SOML is 1176 lines.
Here's the beginning of the sheet:

[[./eg/CG-sheet.png]]

Here is the end of the sheet, which exposes various thesauri (~ConceptSchemes~) 
as distinct business classes

[[./eg/CG-sheet2.png]]

To generate a SOML schema from the google sheet [[https://docs.google.com/spreadsheets/d/1_-bn9Y-9rtysnvKiVus6BkFKXqHhiV4vCjYeiRmb6XU/edit#gid=0][CG-data-model]], call it like this:
: curl -s "https://docs.google.com/spreadsheets/d/1_-bn9Y-9rtysnvKiVus6BkFKXqHhiV4vCjYeiRmb6XU/export?format=tsv" | perl tsv2soml.pl | cat CG-preamble.yaml - > CG.yaml

Here [[./schemas/CG-preamble.yaml][CG-preamble.yaml]] is some fixed SOML metadata (a header).

Options:
- ~-p~: don't emit ~pattern~ (this feature restricts URLs to a certain pattern)
- ~-l~: downgrade Literals: ~stringOrLangString, langString~ -> ~string~, ~dateOrYearOrMonth~ -> ~date~.
  This can be used to simplify the schema not to use ~langString~ and union datatypes

*** Reusing Property Characteristics
:PROPERTIES:
:CUSTOM_ID: reusing-property-characteristics
:END:
- The script counts how many times each prop is used in objects
- For props used more than once, the script emits the *first occurrence* of each prop
  in the common ~properties~ section:
#+begin_src yaml
properties: # reused props
#+end_src
- This allows you to omit common details (eg ~label, descr, range~) on subsequent occurrences
- But it also means that characteristics given in the first occurrence override the defaults
  for subsequent occurrences, which may lead to unintended consequences.

Consider a SOML based on schema.org where we allow multiple ~sameAs~ values
(e.g. the item's Wikipedia page, Wikidata entry, Linkedin profile, YouTube profile, etc),
and want the field to be mandatory for ~Organization~ but optional for ~Person~.

We write the details on the first occurrence and then just mention the prop on the second occurrence:

| Class/prop   | label   | Inherits/range | char             | descr                                                 |
|--------------+---------+----------------+------------------+-------------------------------------------------------|
| Organization |         |                |                  |                                                       |
| sameAs       | same as | iri            | min: 1, max: inf | URL that unambiguously indicates the thing's identity |
| Person       |         |                |                  |                                                       |
| sameAs       |         |                |                  |                                                       |

This results in a SOML like this:
#+begin_src yaml
  objects:
    Organization:
      props:
        sameAs:
          range: iri
          min: 1
          max: inf
          descr: URL that unambiguously indicates the thing's identity
    Person:
      props:
        sameAs:
  properties: # reused props
    sameAs:
      range: iri
      min: 1
      max: inf
      descr: URL that unambiguously indicates the thing's identity
#+end_src
The prop characteristics are copied from ~properties~ into ~Person.props~,
which means that the default cardinality ~min: 0~ is overridden by ~min: 1~,
which doesn't match the requirement "optional for ~Person~".

To fix this, you need to specify ~min: 0~ explicitly in the ~Person.sameAs~ table row.

** soml-map
:PROPERTIES:
:CUSTOM_ID: soml-map
:END:

~tsv2soml~ writes out a file ~soml-map.tsv~ (see exmaple [[./schemas/soml-map.tsv][soml-map.tsv]]) with columns "class, prop (optional), rdf"
- For props without ~RDF~ value, it uses the RDF name from the shared first occurrence of the same prop name

It can be used to map from SOML names to RDF names (class/prop URLs) in specific namespaces.
Eg compare [[*Example Diagram: Exchange Listing SOML][Example Diagram: Exchange Listing SOML]] vs [[*Example Diagram: Exchange Listing RDF][Example Diagram: Exchange Listing RDF]].

It can be used to map examples (models) or conversion scripts (TARQL, or SPARQL Update for OpenRefine)
from a "logical" representation using uniform GraphQL names
to a "physical" representaiton using specific RDF names.

Usage:
: perl soml-map.pl < file.(tarql|ru|ttl) > file-mapped.(tarql|ru|ttl)

** tsv2owl
:PROPERTIES:
:CUSTOM_ID: tsv2owl
:END:
This tool uses the same sheets that drive ~tsv2soml~ to generate an OWL ontology.
You can run it with a Makefile like this (see [[./tsv2owl/Makefile][tsv2owl/Makefile]]):
#+begin_src Makefile
ontology.ttl ::
	curl -Ls "https://docs.google.com/spreadsheets/d/.../export?format=tsv" | \
      perl -S tsv2owl.pl -vocab s: -ontology otkg: | \
      cat ontology-preamble.ttl - > ontology-unformatted.ttl
	riot --formatted=ttl ontology-unformatted.ttl | perl -00e '@a=<>; print sort @a' > ontology.ttl
	# rm ontology-unformatted.ttl # keep for debugging
#+end_src

It works like this:
- Generates term definitions from the sheet
- Prepends the preamble
- Formats the result with Jena ~riot~
- Sorts the file by term (Turtle block: such "paragraphs" are separated by a double newline)

Use an ontology preamble, eg like this ~otkg-preamble.ttl~:

#+begin_src ttl
@prefix otkg: <https://kg.ontotext.com/resource/ontology/>.
@prefix s:    <http://schema.org/> .

<https://kg.ontotext.com/resource/ontology> a owl:Ontology ;
  rdfs:label      "OTKG Ontology" ;
  dct:created     "2023-01-25"^^xsd:date ;
  dct:creator     <http://ontotext.com> ;
  owl:versionInfo "1.0" .
#+end_src

It has these options. 
- ~-v~: default namespace for classes and props that don't have a specific URL in the RDF column.
  - By default is the empty prefix ~:~ (you must define this prefix in the preamble).
  For example, for the Ontotext KG (OTKG), we use  ~-v s: -o otkg:~ i.e. schema.org (s:) as vocabulary namespace but otkg: as the ontology URL. Then eg:
    - ~keywords~ will be emitted as ~s:keywords~ because it doesn't have an RDF value
    - ~buyersJourney~ will be emitted as ~otkg:buyersJourney~ because that is its RDF value
- ~-o:~: ontology URL (optional).
  - Should match the ~owl:Ontology~ that you use in the preamble
  - Can be a prefixed URL (eg ~otkg:~, in this case the URL has a slash at the end)
    or a full URL (eg <https://kg.ontotext.com/resource/ontology> without slash at the end)
  - For each term (class and prop), adds ~rdfs:isDefinedBy~ pointing to the ontology.
    This is a common practice and is used eg by MetaPhactory when collecting properties to generate forms.
  - Adds the current date as ~dct:modified~ of the ontology
- ~-l~: downgrade literal datatypes.
  - Datatypes are mapped as follows:
#+begin_src 
langString            rdf:langString
stringOrLangString    rdf:langString
literal               rdf:Literal
dateOrYearOrMonth     xsd:date
dateOrTimeOrTimeStamp xsd:dateTimeStamp
<datatype>            xsd:<datatype>
#+end_src
  - With this option, the following downgrading (simplification) is also done:
#+begin_src 
rdf:langString        xsd:string
rdf:Literal           xsd:string
#+end_src
     
It uses the following sheet columns:
- ~Class/prop~: class (if capitalized) or property belonging to the class above (if lowercase)
- ~label~: emits ~rdfs:label~, by default same as the first column
- ~Inherits/range~: superclass (if it's a class row) or property range
- ~char~: SOML characteristics:
  - Class: ~kind, typeProp, name, search~: ignored
    - If it's ~kind: abstract~, you'll want to use ~RDF Replacement~ (see below)
  - Prop:
    - ~inverseAlias~: this is a  virtual property, so it's omitted
    - ~min, max~: mapped to ~owl:minCardinality, owl:maxCardinality~ restrictions on the containing class
      (but see https://github.com/VladimirAlexiev/soml/issues/1 for unimplemented features)
    - ~inverseOf~ (prop with or without namespace): mapped to ~owl:inverseOf~
    - ~symmetric~ (only "true"): mapped to ~owl:SymmetricProperty~
    - ~subPropertyOf~: mapped to ~rdfs:subPropertyOf~
    - ~transitiveOver~: mapped to ~psys:transitiveOver~
    - ~search: {...}~: ignored
    - Not yet handled: ~owl:FunctionalProperty~
- ~RDF~: RDF URL used for this class/prop. By default is uses the first column
- ~(regex|pattern)~: ignored (these are used by SOML only)
- ~descr~: emits ~rdfs:comment~
- ~RDF replacement~: optional. See next section

Features and limitations:
- Prop definitions (characteristics, label, descr, range; but not cardinality)
  must conform in each use of a property.
  This is not checked !!!
  Use ~riot --formatted ttl~ to collect them in "paragraphs"
  so you can check whether you have consistent definitions.
- Emits ~schema:domainIncludes~ for each prop to accommodate props used sevreral times.
- Emits type ~owl:ObjectProperty~ vs ~owl:DatatypeProperty~ for each prop, depending on range:
  - If ~iri~ then ~ObjectProperty~
  - If lowercase then ~DatatypeProperty~ (and prepend ~xsd:~ to the range)
  - Else (the range is a class) then ~ObjectProperty~
- Map only the data ranges indicated above: currently doesn't support rdf:HTML, sysont:Markdown
  
*** RDF replacement
:PROPERTIES:
:CUSTOM_ID: rdf-replacement
:END:
The column ~RDF~ is used when you need to specify something different from ~Class/name~.
Eg if you have this in the SOML preamble:
#+begin_src yaml
prefixes:
  vocab_iri: http://schema.org/
  vocab_prefix: s
  #+end_src
The following tabular schema excerpt (leading dashes indicate the class hierarchy):
| Class/prop          | range/inherits | RDF                    |
|---------------------+----------------+------------------------|
| Event               |                |                        |
| -EventSeries        | Event          |                        |
| -EventParticipation | Event          | otkg:EventPartcipation |
generates ~s:Event~, ~s:EventSeries~ and ~otkg:EventPartcipation~ respectively.

Semantic Objects currently supports only abstract superclasses,
so if we want to use all 3 classes with instance data, 
we need to add an abstract parent like this:
| Class/prop          | range/inherits | char           | RDF                    |
|---------------------+----------------+----------------+------------------------|
| EventCommon         |                | kind: abstract |                        |
| -Event              | EventCommon    |                |                        |
| -EventSeries        | EventCommon    |                |                        |
| -EventParticipation | EventCommon    |                | otkg:EventPartcipation |

It's quite common for one of the children (in this case ~Event~) not to have any props of its own, 
just to inherit the props of the parent.

This works fine for ~tsv2soml~, but ~tsv2owl~ would generate a parasitic (non-existent) RDF class ~s:EventCommon~.
I thought of using the value ~RDF: none~ to signal that such class should be omitted.
But then I'd need to carry over the properties and parent of that parasitic class to one of its children (in this case ~Event~).

So instead, I add an extra column ~RDF replacement~ that indicates which RDF class is used instead of the parasitic class:
| Class/prop          | range/inherits | char           | RDF                    | RDF replacement |
|---------------------+----------------+----------------+------------------------+-----------------|
| EventCommon         |                | kind: abstract |                        | Event           |
| -Event              | EventCommon    |                |                        |                 |
| -EventSeries        | EventCommon    |                |                        |                 |
| -EventParticipation | EventCommon    |                | otkg:EventPartcipation |                 |
This replaces all references to ~EventCommon~ with ~Event~: domain (prop attachment), range (prop target), superclass (parent), subclasses (children).

Notes:
- It uses the fact that RDFS/OWL triples can be emitted in any order
- It emits an extra reflexive triple ~s:Event rdfs:subClassOf s:Event~, which is harmless and in fact is part of the RDFS semantics
- It uses the RDF expression of the replacement class: in this case ~s:Event~ because the ~RDF~ column is not used, but you can specify something else in ~RDF~
- ~label~ and ~descr~ of the parasitic class are ignored to avoid emitting multiple labels/descriptions for the replacement class

You can also use replacement on leaf-level classes.
Consider the following example from OTKG (two leading dashes indicate the properties attached to the prev class):
| Class/prop       | range/inherits | char                            | RDF                 | RDF replacement |
|------------------+----------------+---------------------------------+---------------------+-----------------|
| Concept          |                | name: prefLabel, kind: abstract | skos:Concept        |                 |
| --prefLabel      | string         | min: 1                          | skos:prefLabel      |                 |
| --inScheme       | ConceptScheme  |                                 | skos:inScheme       |                 |
| -Audience        | Concept        | typeProp: inScheme              | OTKG:audience       | skos:Concept    |
| -ContentType     | Concept        | typeProp: inScheme              | OTKG:contentType    | skos:Concept    |
| --appliesToClass | iri            |                                 | otkg:appliesToClass |                 |
| PersonCommon     | Thing          | kind: abstract                  |                     | Person          |
| --jobTitle       | string         |                                 |                     |                 |
| --worksFor       | Organization   | min: 1                          |                     |                 |
| --sameAs         | iri            | max: inf                        |                     |                 |
| -Person          | PersonCommon   |                                 |                     |                 |
| -OntotextPerson  | PersonCommon   | typeProp: worksFor              | OTKG-agent:Ontotext | none            |
| --sameAs         | iri            | min: 1                          |                     |                 |
Several sub-classes have an additional type discriminator designated by ~typeProp~ (in addition to the standard ~rdf:type~):
- ~ContentType~ is a ~skos:Concept~ that is further distinguished by ~skos:inScheme~.
  It has extra prop ~otkg:appliesToClass~, so we specify ~replacement=skos:Concept~ to carry over this prop to that parent class.
  Note: this prop indicates which concept goes with which Schema class, eg ~OTKG:contentType/blog_post~ goes with ~s:BlogPosting~
- ~Audience~ adds no props compared to ~Concept~, but we still set ~replacement=skos:Concept~
  to ensure that its incoming link ~s:audience~ will obtain ~range=skos:Concept~
- ~PersonCommon~ is a parasitic (abstract) parent class, so we replace it with ~Person~ (which is emitted in RDF as ~s:Person~).
  We already such replacement case in the previous example.
- ~OntotextPerson~ is a class that is the same as ~Person~, but with fixed ~s:worksFor=OTKG-agent:Ontotext~
  and with stronger information requirements (we demand that it has at least one ~s:sameAs~, the default in ~Person~ is ~min: 0~).
  There's neither RDF class ~s:OntotextPerson~ nor ~otkg:OntotextPerson~, and it doesn't add any extra prop.
  So we use ~replacement=none~ to omit it from RDF altogether.

** soml2puml
:PROPERTIES:
:CUSTOM_ID: soml2puml
:END:
Generate nice PlantUML diagrams from SOML models.
See its own README.

* Tricky Points and Deficiencies
:PROPERTIES:
:CUSTOM_ID: tricky-points-and-deficiencies
:END:

** GraphQL Type vs rdf:type
:PROPERTIES:
:CUSTOM_ID: graphql-type-vs-rdf-type
:END:

** Single vs Multiple-Value Props
:PROPERTIES:
:CUSTOM_ID: single-vs-multiple-value-props
:END:

** Inverse Aliases
:PROPERTIES:
:CUSTOM_ID: inverse-aliases
:END:

** Literals 
:PROPERTIES:
:CUSTOM_ID: literals
:END:
(langString, union datatypes)

** Extended Pattern (Prefix + Regex)
:PROPERTIES:
:CUSTOM_ID: extended-pattern-prefix-regex
:END:

** IRI Generation
:PROPERTIES:
:CUSTOM_ID: iri-generation
:END:

** Schema Inclusion/Modularity
:PROPERTIES:
:CUSTOM_ID: schema-inclusion-modularity
:END:

